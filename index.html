<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <meta name="theme-color" content="#04070c" />
  <meta name="application-name" content="CYBER//SHELL" />
  <meta name="apple-mobile-web-app-title" content="CYBER//SHELL" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />

  <title>CYBER//SHELL â€” Generative Music Console</title>

  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png" />
  <link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png" />
  <link rel="manifest" href="site.webmanifest" />

  <style>
    :root{
      --bg:#04070c;
      --panel:rgba(255,255,255,.05);
      --stroke:rgba(255,255,255,.11);
      --text:rgba(235,245,255,.90);
      --muted:rgba(235,245,255,.62);
      --cyan:#6EF3FF;
      --violet:#B36BFF;
      --lime:#A8FF6E;
      --warn:#ffd26e;
      --danger:#ff6e8a;
      --radius:22px;
      --shadow: 0 26px 90px rgba(0,0,0,.65);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(900px 700px at 10% 20%, rgba(110,243,255,.14), transparent 60%),
        radial-gradient(900px 700px at 85% 25%, rgba(179,107,255,.13), transparent 60%),
        radial-gradient(900px 900px at 50% 120%, rgba(255,255,255,.06), transparent 55%),
        var(--bg);
      color: var(--text);
      overflow-x:hidden;
    }

    .grain{ pointer-events:none; position:fixed; inset:-20%;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='140' height='140'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='140' height='140' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      mix-blend-mode:overlay; opacity:.06;
      animation: drift 10s linear infinite;
      transform: translateZ(0);
    }
    @keyframes drift{ to{ transform:translate3d(-5%,-5%,0);} }

    .scan{ pointer-events:none; position:fixed; inset:0;
      background: linear-gradient(to bottom, rgba(255,255,255,.03), rgba(255,255,255,0) 2px);
      background-size:100% 6px;
      opacity:.07; mix-blend-mode:overlay;
    }

    .hud-grid{ pointer-events:none; position:fixed; inset:0;
      background:
        linear-gradient(to right, rgba(110,243,255,.06) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(110,243,255,.06) 1px, transparent 1px);
      background-size: 64px 64px;
      opacity:.22;
      mask-image: radial-gradient(circle at 50% 35%, rgba(0,0,0,1), rgba(0,0,0,.2) 55%, transparent 75%);
    }

    .beam{ pointer-events:none; position:fixed; left:-20%; right:-20%;
      top:-30%; height: 22%;
      background: linear-gradient(90deg, transparent, rgba(110,243,255,.10), transparent);
      filter: blur(2px);
      opacity:.35;
      animation: beam 6.5s ease-in-out infinite;
    }
    @keyframes beam{
      0%{ transform: translateY(-30vh) rotate(2deg); }
      50%{ transform: translateY(40vh) rotate(-2deg); }
      100%{ transform: translateY(110vh) rotate(2deg); }
    }

    header{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(4,7,12,.55);
      border-bottom:1px solid rgba(255,255,255,.08);
    }

    .wrap{ width:min(1180px, 92vw); margin:0 auto; }
    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:14px; padding: 14px 0; }

    .brand{ display:flex; align-items:center; gap:10px; user-select:none; }
    .logo{
      width: 26px; height: 26px;
      border-radius: 8px;
      box-shadow: 0 0 18px rgba(110,243,255,.22);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .brandtext{ display:flex; flex-direction:column; line-height:1.05; }
    .brandtext .name{
      text-transform:uppercase; letter-spacing:.16em;
      font-weight:900; font-size:12px;
      color:rgba(235,245,255,.82);
    }
    .brandtext .sub{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(235,245,255,.58);
      letter-spacing:.04em;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .btn{
      appearance:none;
      border:1px solid rgba(110,243,255,.22);
      background: rgba(110,243,255,.06);
      color: rgba(235,245,255,.88);
      padding: 10px 12px;
      border-radius:999px;
      font-size:13px;
      cursor:pointer;
      transition: transform .15s ease, background .2s ease, border-color .2s ease;
      display:inline-flex; align-items:center; gap:8px;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(110,243,255,.10); border-color: rgba(110,243,255,.38); }
    .btn:active{ transform: translateY(0); }
    .btn.secondary{ border-color: rgba(255,255,255,.14); background: rgba(255,255,255,.05); }
    .btn.secondary:hover{ border-color: rgba(179,107,255,.30); background: rgba(179,107,255,.08); }
    .btn.danger{ border-color: rgba(255,110,138,.25); background: rgba(255,110,138,.08); }
    .btn.danger:hover{ border-color: rgba(255,110,138,.45); background: rgba(255,110,138,.12); }

    .pill{ font-size:11px; font-family:var(--mono);
      border:1px solid rgba(168,255,110,.25);
      background: rgba(168,255,110,.08);
      padding: 4px 8px;
      border-radius:999px;
      color: rgba(220,255,220,.82);
      letter-spacing:.06em;
    }
    .pill.warn{ border-color: rgba(255,210,110,.28); background: rgba(255,210,110,.08); color: rgba(255,240,220,.86); }
    .pill.off{ border-color: rgba(255,255,255,.14); background: rgba(255,255,255,.05); color: rgba(235,245,255,.72); }

    main{ padding: 18px 0 86px; }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items:start;
      margin-top: 14px;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      position:relative;
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(var(--cyan), var(--cyan)) left 14px top 14px / 22px 1px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) left 14px top 14px / 1px 22px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) right 14px top 14px / 22px 1px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) right 14px top 14px / 1px 22px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) left 14px bottom 14px / 22px 1px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) left 14px bottom 14px / 1px 22px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) right 14px bottom 14px / 22px 1px no-repeat,
        linear-gradient(var(--cyan), var(--cyan)) right 14px bottom 14px / 1px 22px no-repeat;
      opacity:.30; pointer-events:none;
    }
    .card.glow::after{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(680px 280px at var(--mx,30%) var(--my,10%), rgba(110,243,255,.20), transparent 58%);
      opacity:.95;
      pointer-events:none;
    }

    .pad{ padding: 18px; }

    .section-title{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin: 0 0 10px;
    }
    .section-title h2{
      margin:0;
      text-transform:uppercase;
      letter-spacing:.16em;
      font-size:12px;
      color: rgba(235,245,255,.74);
    }

    .subtxt{
      margin: 0 0 12px;
      color: var(--muted);
      line-height:1.6;
      font-size: 13px;
      max-width: 80ch;
    }

    .controls{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }
    @media (max-width: 700px){ .controls{ grid-template-columns: 1fr; } }

    .ctl{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      border-radius: 18px;
      padding: 12px;
      position:relative;
      overflow:hidden;
    }
    .ctl .label{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
    .ctl .label strong{ font-size: 12px; letter-spacing:.08em; text-transform:uppercase; color: rgba(235,245,255,.78); }
    .ctl .label span{ font-family:var(--mono); font-size: 12px; color: rgba(235,245,255,.70); }

    input[type="range"]{ width:100%; margin-top: 10px; accent-color: var(--cyan); }

    select{
      width:100%;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(235,245,255,.88);
      outline: none;
      font-size: 13px;
      font-family: var(--sans);
    }

    .small{ font-size: 12px; color: rgba(235,245,255,.62); line-height:1.5; }

    .meter{ height: 10px; border-radius:999px; background: rgba(255,255,255,.10); overflow:hidden; border:1px solid rgba(255,255,255,.10); }
    .meter > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, rgba(110,243,255,.95), rgba(179,107,255,.95)); box-shadow: 0 0 18px rgba(110,243,255,.45); border-radius:999px; transition: width .25s ease; }

    .log{
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.55;
      color: rgba(235,245,255,.78);
      max-height: 320px;
      overflow:auto;
      padding-right: 6px;
    }
    .log .dim{ color: rgba(235,245,255,.52); }
    .log .ok{ color: rgba(168,255,110,.86); }
    .log .warn{ color: rgba(255,210,110,.86); }
    .log .bad{ color: rgba(255,110,138,.86); }
    .log .id{ color: rgba(110,243,255,.86); }

    .kbd{
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(235,245,255,.80);
    }

    .mapping{ display:flex; flex-direction:column; gap:8px; margin-top: 10px; }
    .maprow{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap:10px;
      align-items:center;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      padding: 10px;
    }
    .maprow .left{ display:flex; flex-direction:column; gap:2px; }
    .maprow .left b{ font-size: 12px; letter-spacing:.06em; }
    .maprow .left span{ font-family:var(--mono); font-size: 11px; color: rgba(235,245,255,.62); }

    .toast{
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(110,243,255,.22);
      padding: 10px 12px;
      border-radius: 999px;
      backdrop-filter: blur(12px);
      color: rgba(235,245,255,.88);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .22s ease, transform .22s ease;
      z-index: 60;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-2px); }

    @media (prefers-reduced-motion: reduce){
      *{ animation:none !important; transition:none !important; scroll-behavior:auto !important; }
      .grain,.scan,.beam{ display:none; }
    }

    :focus-visible{ outline: 2px solid rgba(110,243,255,.65); outline-offset: 3px; border-radius: 10px; }
  </style>
</head>

<body>
  <div class="grain" aria-hidden="true"></div>
  <div class="scan" aria-hidden="true"></div>
  <div class="hud-grid" aria-hidden="true"></div>
  <div class="beam" aria-hidden="true"></div>

  <header>
    <div class="wrap">
      <div class="topbar">
        <div class="brand">
          <img class="logo" src="icon-192x192.png" alt="CYBER//SHELL" width="26" height="26" />
          <div class="brandtext">
            <div class="name">CYBER//SHELL</div>
            <div class="sub">Generative Music Console</div>
          </div>
          <span class="pill off" id="audioState">AUDIO: OFF</span>
          <span class="pill off" id="midiState">MIDI: OFF</span>
        </div>
        <div class="row">
          <button class="btn" id="startBtn" type="button">â–¶ Start</button>
          <button class="btn secondary" id="stopBtn" type="button">â–  Stop</button>
          <button class="btn secondary" id="randomNowBtn" type="button">âš¡ Random Now</button>
          <button class="btn danger" id="panicBtn" type="button">â›” Panic</button>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <section class="card glow pad" id="leftCard" aria-label="Sound engine">
        <div class="section-title">
          <h2>Sound Engine</h2>
          <span class="pill" id="scenePill">SCENE: NEON ALLEY</span>
        </div>
        <p class="subtxt">
          A fully client-side cyberpunk music generator powered by WebAudio, with optional WebMIDI control.
          Use Random Now or schedule randomization in seconds. Agency evolves patterns while keeping the vibe coherent.
        </p>

        <div class="controls">
          <div class="ctl">
            <div class="label"><strong>Tempo</strong><span><span id="tempoVal">128</span> BPM</span></div>
            <input id="tempo" type="range" min="70" max="170" step="1" value="128" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Randomize Every</strong><span><span id="randEveryVal">12</span>s</span></div>
            <input id="randEvery" type="range" min="0" max="30" step="1" value="12" />
            <div class="small">Set to 0 to disable scheduled randomization.</div>
          </div>

          <div class="ctl">
            <div class="label"><strong>Scene</strong><span id="sceneDesc">Detuned bass + glass lead</span></div>
            <select id="scene">
              <option value="neon">Neon Alley (balanced)</option>
              <option value="raid">Night Raid (aggressive)</option>
              <option value="dream">Synthetic Dream (lush)</option>
              <option value="dystopia">Dystopia Terminal (industrial)</option>
            </select>
          </div>

          <div class="ctl">
            <div class="label"><strong>Agency Mode</strong><span id="agencyModeLabel">Evolved</span></div>
            <select id="agencyMode">
              <option value="evolved">Evolved (goal-driven)</option>
              <option value="chaos">Chaos (high variance)</option>
              <option value="minimal">Minimal (low variance)</option>
              <option value="locked">Locked (no auto-changes)</option>
            </select>
          </div>

          <div class="ctl">
            <div class="label"><strong>Kick Level</strong><span id="kickVal">0.75</span></div>
            <input id="kick" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Bass Level</strong><span id="bassVal">0.70</span></div>
            <input id="bass" type="range" min="0" max="1" step="0.01" value="0.70" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Lead Level</strong><span id="leadVal">0.55</span></div>
            <input id="lead" type="range" min="0" max="1" step="0.01" value="0.55" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Hat Level</strong><span id="hatVal">0.45</span></div>
            <input id="hat" type="range" min="0" max="1" step="0.01" value="0.45" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Filter Cutoff</strong><span><span id="cutoffVal">1400</span> Hz</span></div>
            <input id="cutoff" type="range" min="120" max="8000" step="1" value="1400" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Resonance (Q)</strong><span id="qVal">1.2</span></div>
            <input id="q" type="range" min="0.2" max="18" step="0.1" value="1.2" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Reverb</strong><span id="revVal">0.18</span></div>
            <input id="reverb" type="range" min="0" max="0.65" step="0.01" value="0.18" />
          </div>

          <div class="ctl">
            <div class="label"><strong>Delay</strong><span id="delVal">0.24</span></div>
            <input id="delay" type="range" min="0" max="0.65" step="0.01" value="0.24" />
          </div>
        </div>

        <div class="row" style="margin-top:14px; justify-content:space-between;">
          <div class="small">
            Shortcuts: <span class="kbd">R</span> random preset, <span class="kbd">Space</span> start/stop.
            MIDI learn: click Learn next to a parameter and move a knob.
          </div>
          <div class="row">
            <button class="btn secondary" id="saveBtn" type="button">ðŸ’¾ Save Preset</button>
            <button class="btn secondary" id="loadBtn" type="button">ðŸ“¥ Load Preset</button>
          </div>
        </div>
      </section>

      <aside class="card glow pad" id="rightCard" aria-label="MIDI and Agency">
        <div class="section-title">
          <h2>MIDI / Agency</h2>
          <div class="row" style="gap:8px;">
            <button class="btn secondary" id="midiBtn" type="button">ðŸŽ› Enable MIDI</button>
            <span class="pill off" id="learnPill">LEARN: OFF</span>
          </div>
        </div>

        <p class="subtxt">
          MIDI control uses WebMIDI (Chrome/Edge recommended). Agency is goal-driven and keeps a cyberpunk mood while evolving density and modulation.
        </p>

        <div class="ctl" style="margin-bottom:12px;">
          <div class="label"><strong>Agency Intensity</strong><span id="agiVal">0.62</span></div>
          <input id="agencyIntensity" type="range" min="0" max="1" step="0.01" value="0.62" />
          <div class="small">Higher = faster evolution and more modulation.</div>
        </div>

        <div class="ctl" style="margin-bottom:12px;">
          <div class="label"><strong>Stability</strong><span id="stabVal">0.55</span></div>
          <input id="stability" type="range" min="0" max="1" step="0.01" value="0.55" />
          <div class="small">Higher = fewer surprises and longer motifs.</div>
        </div>

        <div class="ctl" style="margin-bottom:12px;">
          <div class="label"><strong>Energy</strong><span id="engVal">0.68</span></div>
          <input id="energy" type="range" min="0" max="1" step="0.01" value="0.68" />
          <div class="small">Guides density, accents, and saturation.</div>
        </div>

        <div class="section-title" style="margin-top:6px;">
          <h2>MIDI Mappings</h2>
          <span class="pill" id="mapCount">0 mapped</span>
        </div>
        <div class="mapping" id="mapping"></div>

        <div class="section-title" style="margin-top:14px;">
          <h2>System Log</h2>
          <div class="row" style="gap:8px;">
            <span class="pill" id="statusPill">ONLINE</span>
            <span class="pill off" id="schedPill">AUTO-RAND: OFF</span>
          </div>
        </div>
        <div class="meter" aria-label="Signal"><i id="sig"></i></div>
        <div class="log" id="log" aria-live="polite" style="margin-top:10px;"></div>

        <div class="row" style="margin-top:12px; justify-content:space-between;">
          <button class="btn secondary" id="clearMapBtn" type="button">ðŸ§¹ Clear Mappings</button>
          <button class="btn secondary" id="exportMapBtn" type="button">â¤“ Export</button>
          <button class="btn secondary" id="importMapBtn" type="button">â¤’ Import</button>
        </div>
      </aside>
    </div>
  </main>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    const $ = (s, el=document) => el.querySelector(s);
    const $$ = (s, el=document) => [...el.querySelectorAll(s)];

    const toast = (msg) => {
      const t = $("#toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(toast._id);
      toast._id = setTimeout(() => t.classList.remove("show"), 1400);
    };

    const logEl = $("#log");
    const ts = () => new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
    const pushLog = (kind, msg) => {
      const line = document.createElement("div");
      const cls = kind === "ok" ? "ok" : kind === "warn" ? "warn" : kind === "bad" ? "bad" : "dim";
      line.innerHTML = `<span class="dim">[${ts()}]</span> <span class="id">${kind.toUpperCase()}</span> <span class="${cls}">${msg}</span>`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    };

    const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const glowCards = [$("#leftCard"), $("#rightCard")].filter(Boolean);
    const setGlow = (el, x, y) => {
      const r = el.getBoundingClientRect();
      const mx = ((x - r.left) / r.width) * 100;
      const my = ((y - r.top) / r.height) * 100;
      el.style.setProperty("--mx", mx + "%");
      el.style.setProperty("--my", my + "%");
    };
    if (!reduceMotion){
      let raf = null;
      window.addEventListener("mousemove", (e) => {
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          for (const el of glowCards) setGlow(el, e.clientX, e.clientY);
        });
      }, {passive:true});
      window.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        if (!t) return;
        for (const el of glowCards) setGlow(el, t.clientX, t.clientY);
      }, {passive:true});
    }

    const state = {
      running: false,
      tempo: 128,
      scene: "neon",
      agencyMode: "evolved",
      agencyIntensity: 0.62,
      stability: 0.55,
      energy: 0.68,
      randEvery: 12,
      levels: { kick: 0.75, bass: 0.70, lead: 0.55, hat: 0.45 },
      fx: { cutoff: 1400, q: 1.2, reverb: 0.18, delay: 0.24 },
      seed: Math.floor(Math.random() * 1e9),
      key: 0,
      scale: "phrygian",
      bassPattern: [],
      leadPattern: [],
      drum: { kick: [], hat: [], sn: [] },
      lastRandAt: 0,
      midi: { enabled: false, access: null, input: null, learn: null, maps: {} }
    };

    const bindRange = (id, getter, setter, labelEl, fmt=(v)=>String(v)) => {
      const el = $(id);
      el.value = getter();
      labelEl.textContent = fmt(el.value);
      el.addEventListener("input", () => {
        setter(el.value);
        labelEl.textContent = fmt(el.value);
        applyParamsToAudio();
      });
    };

    bindRange("#tempo", () => state.tempo, v => state.tempo = parseInt(v,10), $("#tempoVal"));
    bindRange("#randEvery", () => state.randEvery, v => state.randEvery = parseInt(v,10), $("#randEveryVal"));

    bindRange("#kick", () => state.levels.kick, v => state.levels.kick = parseFloat(v), $("#kickVal"), v => (+v).toFixed(2));
    bindRange("#bass", () => state.levels.bass, v => state.levels.bass = parseFloat(v), $("#bassVal"), v => (+v).toFixed(2));
    bindRange("#lead", () => state.levels.lead, v => state.levels.lead = parseFloat(v), $("#leadVal"), v => (+v).toFixed(2));
    bindRange("#hat",  () => state.levels.hat,  v => state.levels.hat  = parseFloat(v), $("#hatVal"),  v => (+v).toFixed(2));

    bindRange("#cutoff", () => state.fx.cutoff, v => state.fx.cutoff = parseInt(v,10), $("#cutoffVal"));
    bindRange("#q",      () => state.fx.q,      v => state.fx.q      = parseFloat(v), $("#qVal"), v => (+v).toFixed(1));
    bindRange("#reverb", () => state.fx.reverb, v => state.fx.reverb = parseFloat(v), $("#revVal"), v => (+v).toFixed(2));
    bindRange("#delay",  () => state.fx.delay,  v => state.fx.delay  = parseFloat(v), $("#delVal"), v => (+v).toFixed(2));

    bindRange("#agencyIntensity", () => state.agencyIntensity, v => state.agencyIntensity = parseFloat(v), $("#agiVal"), v => (+v).toFixed(2));
    bindRange("#stability",       () => state.stability,       v => state.stability       = parseFloat(v), $("#stabVal"), v => (+v).toFixed(2));
    bindRange("#energy",          () => state.energy,          v => state.energy          = parseFloat(v), $("#engVal"), v => (+v).toFixed(2));

    $("#scene").addEventListener("change", (e) => {
      state.scene = e.target.value;
      updateSceneUI();
      agencyNudge("scene");
      applyParamsToAudio();
      pushLog("ok", `SCENE: ${sceneName(state.scene)}`);
    });

    $("#agencyMode").addEventListener("change", (e) => {
      state.agencyMode = e.target.value;
      $("#agencyModeLabel").textContent = state.agencyMode[0].toUpperCase() + state.agencyMode.slice(1);
      pushLog("ok", `AGENCY_MODE: ${state.agencyMode.toUpperCase()}`);
    });

    $("#startBtn").addEventListener("click", async () => {
      await ensureAudio();
      start();
    });
    $("#stopBtn").addEventListener("click", () => stop());
    $("#panicBtn").addEventListener("click", () => panic());
    $("#randomNowBtn").addEventListener("click", () => { randomizePreset("manual"); toast("Randomized"); });
    $("#saveBtn").addEventListener("click", () => savePreset());
    $("#loadBtn").addEventListener("click", () => loadPreset());

    window.addEventListener("keydown", (e) => {
      if (e.repeat) return;
      if (e.code === "Space"){
        e.preventDefault();
        state.running ? stop() : $("#startBtn").click();
      }
      if (e.key.toLowerCase() === "r"){
        randomizePreset("hotkey");
        toast("Randomized");
      }
    });

    const SCENES = {
      neon: { name: "Neon Alley", desc: "Detuned bass + glass lead", tempoBias: [118, 138], cutoff: [900, 2200], q: [0.7, 2.5], delay: [0.14, 0.32], reverb: [0.10, 0.22], energyBias: 0.65 },
      raid: { name: "Night Raid", desc: "Hard kick + gritty bass", tempoBias: [132, 165], cutoff: [650, 1700], q: [1.0, 5.5], delay: [0.08, 0.22], reverb: [0.06, 0.18], energyBias: 0.82 },
      dream: { name: "Synthetic Dream", desc: "Wide pads + airy echoes", tempoBias: [88, 128], cutoff: [1200, 3800], q: [0.4, 1.9], delay: [0.18, 0.40], reverb: [0.18, 0.45], energyBias: 0.52 },
      dystopia: { name: "Dystopia Terminal", desc: "Industrial hats + cold lead", tempoBias: [108, 146], cutoff: [500, 1600], q: [2.0, 10.0], delay: [0.10, 0.30], reverb: [0.05, 0.18], energyBias: 0.74 }
    };

    const sceneName = (k) => (SCENES[k]?.name ?? k);

    function updateSceneUI(){
      const s = SCENES[state.scene] || SCENES.neon;
      $("#scenePill").textContent = `SCENE: ${s.name.toUpperCase()}`;
      $("#sceneDesc").textContent = s.desc;
    }

    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function pick(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }

    const SCALES = {
      phrygian: [0,1,3,5,7,8,10],
      minor:    [0,2,3,5,7,8,10],
      harmonic: [0,2,3,5,7,8,11],
      locrian:  [0,1,3,5,6,8,10]
    };

    function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

    function buildScale(key, scaleName){
      const steps = SCALES[scaleName] || SCALES.phrygian;
      return steps.map(s => (key + s) % 12);
    }

    let ac = null;
    let master = null;
    let filter = null;
    let delay = null;
    let delayFb = null;
    let delayMix = null;
    let revMix = null;
    let reverbNode = null;

    let kickGain, hatGain, snGain, bassGain, leadGain;

    let nextTickTime = 0;
    let tickTimer = null;
    let tickIndex = 0;
    const STEPS = 16;

    async function ensureAudio(){
      if (ac) return;
      ac = new (window.AudioContext || window.webkitAudioContext)();

      master = ac.createGain();
      master.gain.value = 0.85;

      filter = ac.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = state.fx.cutoff;
      filter.Q.value = state.fx.q;

      delay = ac.createDelay(1.0);
      delay.delayTime.value = 0.18;
      delayFb = ac.createGain();
      delayFb.gain.value = 0.25;
      delayMix = ac.createGain();
      delayMix.gain.value = 0.0;
      delay.connect(delayFb).connect(delay);

      reverbNode = ac.createConvolver();
      reverbNode.buffer = makeImpulseResponse(ac, 1.8, 2.0);
      revMix = ac.createGain();
      revMix.gain.value = 0.0;

      const dry = ac.createGain();
      dry.gain.value = 1.0;

      filter.connect(dry).connect(master);
      filter.connect(delay).connect(delayMix).connect(master);
      filter.connect(reverbNode).connect(revMix).connect(master);

      master.connect(ac.destination);

      kickGain = ac.createGain();
      hatGain = ac.createGain();
      snGain = ac.createGain();
      bassGain = ac.createGain();
      leadGain = ac.createGain();

      kickGain.gain.value = state.levels.kick;
      hatGain.gain.value  = state.levels.hat;
      snGain.gain.value   = 0.45;
      bassGain.gain.value = state.levels.bass;
      leadGain.gain.value = state.levels.lead;

      kickGain.connect(filter);
      hatGain.connect(filter);
      snGain.connect(filter);
      bassGain.connect(filter);
      leadGain.connect(filter);

      $("#audioState").textContent = "AUDIO: ON";
      $("#audioState").classList.remove("off");
      pushLog("ok", "AUDIO: initialized");

      randomizePreset("boot");
      applyParamsToAudio();

      setInterval(() => {
        if (!ac) return;
        const v = state.running ? (0.35 + 0.65*Math.random()) : 0.12;
        $("#sig").style.width = Math.round(v*100) + "%";
      }, 220);
    }

    function makeImpulseResponse(audioCtx, duration=1.5, decay=2.0){
      const rate = audioCtx.sampleRate;
      const length = Math.floor(rate * duration);
      const impulse = audioCtx.createBuffer(2, length, rate);
      for (let c=0; c<2; c++){
        const ch = impulse.getChannelData(c);
        for (let i=0; i<length; i++){
          const t = i/length;
          ch[i] = (Math.random()*2-1) * Math.pow(1-t, decay);
        }
      }
      return impulse;
    }

    function applyParamsToAudio(){
      updateSceneUI();
      $("#agencyModeLabel").textContent = state.agencyMode[0].toUpperCase() + state.agencyMode.slice(1);
      $("#schedPill").textContent = state.randEvery > 0 ? `AUTO-RAND: ${state.randEvery}s` : "AUTO-RAND: OFF";
      $("#schedPill").classList.toggle("off", state.randEvery === 0);

      if (!ac) return;

      kickGain.gain.setTargetAtTime(state.levels.kick, ac.currentTime, 0.02);
      hatGain.gain.setTargetAtTime(state.levels.hat, ac.currentTime, 0.02);
      bassGain.gain.setTargetAtTime(state.levels.bass, ac.currentTime, 0.02);
      leadGain.gain.setTargetAtTime(state.levels.lead, ac.currentTime, 0.02);

      filter.frequency.setTargetAtTime(state.fx.cutoff, ac.currentTime, 0.03);
      filter.Q.setTargetAtTime(state.fx.q, ac.currentTime, 0.03);

      delayMix.gain.setTargetAtTime(state.fx.delay, ac.currentTime, 0.05);
      revMix.gain.setTargetAtTime(state.fx.reverb, ac.currentTime, 0.06);

      const beat = 60 / state.tempo;
      const d = clamp(beat * (0.25 + 0.5*state.fx.delay), 0.06, 0.55);
      delay.delayTime.setTargetAtTime(d, ac.currentTime, 0.06);
      delayFb.gain.setTargetAtTime(clamp(0.12 + state.fx.delay*0.45, 0.10, 0.60), ac.currentTime, 0.08);
    }

    function playKick(t, strength=1){
      const o = ac.createOscillator();
      const g = ac.createGain();
      const sh = ac.createWaveShaper();

      o.type = "sine";
      o.frequency.setValueAtTime(140, t);
      o.frequency.exponentialRampToValueAtTime(55, t + 0.09);

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.9 * strength, t + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);

      sh.curve = makeSaturationCurve(lerp(40, 120, state.energy));
      sh.oversample = "2x";

      o.connect(sh).connect(g).connect(kickGain);
      o.start(t);
      o.stop(t + 0.18);
    }

    function playHat(t, open=false, strength=1){
      const src = ac.createBufferSource();
      src.buffer = noiseBuffer(ac);
      const bp = ac.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = open ? 9200 : 11000;
      bp.Q.value = open ? 0.7 : 1.2;
      const hp = ac.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 6500;
      const g = ac.createGain();

      const dur = open ? 0.10 : 0.04;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.35 * strength, t + 0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      src.connect(bp).connect(hp).connect(g).connect(hatGain);
      src.start(t);
      src.stop(t + dur + 0.02);
    }

    function playSnare(t, strength=1){
      const src = ac.createBufferSource();
      src.buffer = noiseBuffer(ac);
      const hp = ac.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 1800;
      const g = ac.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.35 * strength, t + 0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

      const o = ac.createOscillator();
      const tg = ac.createGain();
      o.type = "triangle";
      o.frequency.setValueAtTime(210, t);
      tg.gain.setValueAtTime(0.0001, t);
      tg.gain.exponentialRampToValueAtTime(0.12 * strength, t + 0.004);
      tg.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

      src.connect(hp).connect(g).connect(snGain);
      o.connect(tg).connect(snGain);

      src.start(t);
      src.stop(t + 0.14);
      o.start(t);
      o.stop(t + 0.10);
    }

    function playBass(t, midi, length=0.12, accent=1){
      const o1 = ac.createOscillator();
      const o2 = ac.createOscillator();
      const g = ac.createGain();
      const sh = ac.createWaveShaper();
      const lp = ac.createBiquadFilter();

      o1.type = "sawtooth";
      o2.type = "sawtooth";
      o1.frequency.setValueAtTime(midiToHz(midi), t);
      o2.frequency.setValueAtTime(midiToHz(midi), t);
      o2.detune.value = lerp(6, 18, state.energy);

      lp.type = "lowpass";
      lp.frequency.setValueAtTime(lerp(520, 1200, state.energy), t);
      lp.Q.value = lerp(0.7, 2.2, state.energy);

      sh.curve = makeSaturationCurve(lerp(60, 240, state.energy));
      sh.oversample = "2x";

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.25 * accent, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + length);

      o1.connect(lp);
      o2.connect(lp);
      lp.connect(sh).connect(g).connect(bassGain);
      o1.start(t); o2.start(t);
      o1.stop(t + length + 0.05); o2.stop(t + length + 0.05);
    }

    function playLead(t, midi, length=0.18, accent=1){
      const o = ac.createOscillator();
      const g = ac.createGain();
      const bp = ac.createBiquadFilter();

      o.type = "triangle";
      o.frequency.setValueAtTime(midiToHz(midi), t);

      o.detune.setValueAtTime(-20, t);
      o.detune.linearRampToValueAtTime(0, t + 0.03);

      bp.type = "bandpass";
      bp.frequency.setValueAtTime(lerp(1100, 2600, state.energy), t);
      bp.Q.value = lerp(1.2, 4.0, state.energy);

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.18 * accent, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + length);

      o.connect(bp).connect(g).connect(leadGain);
      o.start(t);
      o.stop(t + length + 0.05);
    }

    let _noiseBuf = null;
    function noiseBuffer(audioCtx){
      if (_noiseBuf) return _noiseBuf;
      const length = Math.floor(audioCtx.sampleRate * 1.0);
      const buf = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
      const ch = buf.getChannelData(0);
      for (let i=0;i<length;i++) ch[i] = Math.random()*2-1;
      _noiseBuf = buf;
      return buf;
    }

    function makeSaturationCurve(amount=100){
      const n = 2048;
      const curve = new Float32Array(n);
      const k = amount;
      for (let i=0; i<n; i++){
        const x = (i * 2 / (n-1)) - 1;
        curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
      }
      return curve;
    }

    function randomizePreset(reason="manual"){
      const rng = mulberry32((state.seed = Math.floor(Math.random()*1e9)));
      const s = SCENES[state.scene] || SCENES.neon;

      state.key = Math.floor(rng()*12);
      state.scale = pick(rng, ["phrygian","minor","harmonic","locrian"]);

      const t = Math.round(lerp(s.tempoBias[0], s.tempoBias[1], rng()));
      state.tempo = clamp(Math.round(lerp(state.tempo, t, 0.65)), 70, 170);
      $("#tempo").value = state.tempo;
      $("#tempoVal").textContent = String(state.tempo);

      state.fx.cutoff = Math.round(lerp(s.cutoff[0], s.cutoff[1], rng()));
      state.fx.q = +lerp(s.q[0], s.q[1], rng()).toFixed(1);
      state.fx.delay = +lerp(s.delay[0], s.delay[1], rng()).toFixed(2);
      state.fx.reverb = +lerp(s.reverb[0], s.reverb[1], rng()).toFixed(2);

      const e = clamp(lerp(s.energyBias, state.energy, 0.5), 0, 1);
      state.levels.kick = +clamp(0.62 + e*0.28 + (rng()-0.5)*0.08, 0, 1).toFixed(2);
      state.levels.bass = +clamp(0.55 + e*0.30 + (rng()-0.5)*0.10, 0, 1).toFixed(2);
      state.levels.lead = +clamp(0.38 + (1-state.stability)*0.18 + (rng()-0.5)*0.10, 0, 1).toFixed(2);
      state.levels.hat  = +clamp(0.25 + e*0.35 + (rng()-0.5)*0.12, 0, 1).toFixed(2);

      $("#kick").value = state.levels.kick; $("#kickVal").textContent = state.levels.kick.toFixed(2);
      $("#bass").value = state.levels.bass; $("#bassVal").textContent = state.levels.bass.toFixed(2);
      $("#lead").value = state.levels.lead; $("#leadVal").textContent = state.levels.lead.toFixed(2);
      $("#hat").value  = state.levels.hat;  $("#hatVal").textContent  = state.levels.hat.toFixed(2);

      $("#cutoff").value = state.fx.cutoff; $("#cutoffVal").textContent = String(state.fx.cutoff);
      $("#q").value      = state.fx.q;      $("#qVal").textContent      = state.fx.q.toFixed(1);
      $("#delay").value  = state.fx.delay;  $("#delVal").textContent     = state.fx.delay.toFixed(2);
      $("#reverb").value = state.fx.reverb; $("#revVal").textContent     = state.fx.reverb.toFixed(2);

      state.bassPattern = genBassPattern(rng);
      state.leadPattern = genLeadPattern(rng);
      state.drum = genDrumPattern(rng);

      applyParamsToAudio();
      pushLog("ok", `PRESET: randomized (${reason}) | key=${state.key} scale=${state.scale}`);
    }

    function genDrumPattern(rng){
      const e = state.energy;
      const stab = state.stability;

      const kick = Array(STEPS).fill(0);
      [0,4,8,12].forEach(i => kick[i] = 1);
      if (rng() < (0.25 + 0.35*e)) kick[10] = 0.8;
      if (rng() < (0.20 + 0.25*e)) kick[14] = 0.7;
      if (rng() < (0.18 + 0.22*e)) kick[6]  = 0.6;
      if (rng() < (0.10 + 0.25*(1-stab))) kick[3] = 0.5;

      const sn = Array(STEPS).fill(0);
      sn[4] = 0.85; sn[12] = 0.90;
      if (rng() < (0.25 + 0.25*(1-stab))) sn[11] = 0.35;
      if (rng() < (0.20 + 0.30*(1-stab))) sn[15] = 0.25;

      const hat = Array(STEPS).fill(0);
      const baseProb = clamp(0.35 + e*0.55, 0.35, 0.95);
      for (let i=0;i<STEPS;i++){
        const on8 = (i % 2 === 0);
        const p = baseProb * (on8 ? 1.0 : (0.75 + 0.25*(1-stab)));
        if (rng() < p) hat[i] = 0.45 + 0.55*rng();
      }
      if (rng() < 0.55) hat[6] = 1.2;
      if (rng() < 0.55) hat[14] = 1.2;

      return {kick, sn, hat};
    }

    function genBassPattern(rng){
      const scale = buildScale(state.key, state.scale);
      const e = state.energy;
      const stab = state.stability;

      const rootPc = pick(rng, [scale[0], scale[2], scale[4]]);
      const rootMidi = 36 + rootPc;

      const pat = Array(STEPS).fill(null);
      const density = clamp(0.25 + e*0.45, 0.2, 0.75);
      for (let i=0;i<STEPS;i++){
        if (i % 4 === 0) {
          pat[i] = {m: rootMidi, len: 0.13, acc: 1.0};
          continue;
        }
        const p = density * (i%2===0 ? 0.9 : 0.7);
        if (rng() < p){
          const octave = rng() < 0.18 + 0.22*e ? 12 : 0;
          const pc = pick(rng, [scale[0], scale[1], scale[2], scale[4], scale[5]]);
          const m = 36 + pc + octave;
          const len = 0.10 + rng()*0.08;
          const acc = 0.65 + rng()*0.55;
          pat[i] = {m, len, acc};
        }
      }
      if (stab > 0.55){
        for (let i=8;i<STEPS;i++) if (pat[i] == null && rng() < 0.22) pat[i] = pat[i-8];
      }
      return pat;
    }

    function genLeadPattern(rng){
      const scale = buildScale(state.key, state.scale);
      const e = state.energy;
      const stab = state.stability;
      const pat = Array(STEPS).fill(null);

      const baseMidi = 60 + pick(rng, [0, 2, 5]);
      const anchors = [0, 6, 8, 14].filter(() => rng() < (0.55 - 0.20*stab + 0.20*e));
      for (const i of anchors){
        const pc = pick(rng, [scale[0], scale[2], scale[4], scale[6]]);
        pat[i] = {m: baseMidi + pc, len: 0.16 + rng()*0.10, acc: 0.9};
      }

      const density = clamp(0.10 + (1-stab)*0.35 + e*0.15, 0.08, 0.55);
      for (let i=0;i<STEPS;i++){
        if (pat[i]) continue;
        if (rng() < density){
          const pc = pick(rng, [scale[0], scale[1], scale[2], scale[3], scale[4], scale[5], scale[6]]);
          const octave = rng() < 0.22 ? 12 : 0;
          const m = baseMidi + pc + octave;
          const len = 0.12 + rng()*0.16;
          const acc = 0.55 + rng()*0.55;
          pat[i] = {m, len, acc};
        }
      }

      if (stab > 0.62 && rng() < 0.75){
        for (let i=8;i<16;i++) if (!pat[i] && pat[i-8] && rng() < 0.75) pat[i] = {...pat[i-8]};
      }

      return pat;
    }

    function agencyTick(){
      if (state.agencyMode === "locked") return;

      const intensity = state.agencyIntensity;
      const stab = state.stability;
      const e = state.energy;

      const evolveProb =
        state.agencyMode === "minimal" ? 0.08 * intensity :
        state.agencyMode === "chaos"   ? 0.35 * intensity :
                                         0.18 * intensity;

      if (Math.random() > evolveProb) return;

      const rng = mulberry32((state.seed = (state.seed + 1) >>> 0));
      const scene = SCENES[state.scene] || SCENES.neon;

      const cutoffTarget = lerp(scene.cutoff[0], scene.cutoff[1], clamp(0.35 + 0.55*e + (rng()-0.5)*0.25, 0, 1));
      state.fx.cutoff = Math.round(lerp(state.fx.cutoff, cutoffTarget, 0.18 + 0.25*intensity));
      state.fx.q = +clamp(state.fx.q + (rng()-0.5)*0.35*(1-stab)*intensity, 0.2, 18).toFixed(1);

      state.energy = clamp(state.energy + (rng()-0.5)*0.06*(1-stab)*intensity, 0, 1);
      $("#energy").value = state.energy;
      $("#engVal").textContent = state.energy.toFixed(2);

      if (state.agencyMode === "chaos" && rng() < 0.45){
        state.scale = pick(rng, ["phrygian","locrian","harmonic"]);
      } else if (state.agencyMode === "evolved" && rng() < 0.18){
        state.scale = pick(rng, [state.scale, "phrygian", "minor", "locrian"]);
      }

      if (rng() < (0.35 + 0.25*(1-stab))*intensity) state.drum = genDrumPattern(rng);
      if (rng() < (0.28 + 0.30*(1-stab))*intensity) state.bassPattern = mutatePattern(state.bassPattern, rng, "bass");
      if (rng() < (0.20 + 0.35*(1-stab))*intensity) state.leadPattern = mutatePattern(state.leadPattern, rng, "lead");

      const levelDrift = (x) => clamp(x + (rng()-0.5)*0.04*(1-stab)*intensity, 0, 1);
      state.levels.kick = +levelDrift(state.levels.kick).toFixed(2);
      state.levels.bass = +levelDrift(state.levels.bass).toFixed(2);
      state.levels.lead = +levelDrift(state.levels.lead).toFixed(2);
      state.levels.hat  = +levelDrift(state.levels.hat ).toFixed(2);

      $("#kick").value = state.levels.kick; $("#kickVal").textContent = state.levels.kick.toFixed(2);
      $("#bass").value = state.levels.bass; $("#bassVal").textContent = state.levels.bass.toFixed(2);
      $("#lead").value = state.levels.lead; $("#leadVal").textContent = state.levels.lead.toFixed(2);
      $("#hat").value  = state.levels.hat;  $("#hatVal").textContent  = state.levels.hat.toFixed(2);

      $("#cutoff").value = state.fx.cutoff; $("#cutoffVal").textContent = String(state.fx.cutoff);
      $("#q").value      = state.fx.q;      $("#qVal").textContent      = state.fx.q.toFixed(1);

      applyParamsToAudio();
      pushLog("ok", `AGENCY: evolved | scale=${state.scale} energy=${state.energy.toFixed(2)} cutoff=${state.fx.cutoff}Hz`);
    }

    function mutatePattern(pat, rng, kind){
      const out = pat.map(x => (x ? {...x} : null));
      const scale = buildScale(state.key, state.scale);
      const e = state.energy;

      const n = 1 + Math.floor(rng()*3);
      for (let k=0;k<n;k++){
        const i = Math.floor(rng()*STEPS);
        if (rng() < 0.28) { out[i] = null; continue; }

        const base = kind === "bass" ? 36 : 60;
        const octave = kind === "bass" ? (rng() < 0.14 + 0.22*e ? 12 : 0) : (rng()<0.22 ? 12 : 0);
        const pc = pick(rng, [scale[0], scale[1], scale[2], scale[4], scale[5], scale[6]]);
        out[i] = { m: base + pc + octave, len: kind === "bass" ? 0.10 + rng()*0.10 : 0.12 + rng()*0.18, acc: 0.55 + rng()*0.60 };
      }
      return out;
    }

    function agencyNudge(reason){
      if (state.agencyMode === "locked") return;
      if (reason === "scene"){
        const target = SCENES[state.scene]?.energyBias ?? 0.65;
        state.energy = clamp(lerp(state.energy, target, 0.35), 0, 1);
        $("#energy").value = state.energy;
        $("#engVal").textContent = state.energy.toFixed(2);
      }
    }

    function start(){
      if (!ac) return;
      if (state.running) return;

      state.running = true;
      $("#statusPill").textContent = "RUNNING";
      $("#statusPill").classList.remove("off");
      pushLog("ok", "TRANSPORT: start");
      toast("Start");

      tickIndex = 0;
      nextTickTime = ac.currentTime + 0.05;
      tickTimer = setInterval(schedule, 25);
    }

    function stop(){
      state.running = false;
      if (tickTimer) clearInterval(tickTimer);
      tickTimer = null;
      $("#statusPill").textContent = "ONLINE";
      toast("Stop");
      pushLog("warn", "TRANSPORT: stop");
    }

    function panic(){
      if (!ac) return;
      stop();
      master.gain.setTargetAtTime(0.0001, ac.currentTime, 0.01);
      setTimeout(() => {
        if (!ac) return;
        master.gain.setTargetAtTime(0.85, ac.currentTime, 0.04);
      }, 120);
      pushLog("bad", "PANIC: master muted momentarily");
      toast("Panic");
    }

    function schedule(){
      if (!state.running) return;
      const secondsPerBeat = 60 / state.tempo;
      const stepDur = secondsPerBeat / 4;

      while (nextTickTime < ac.currentTime + 0.12){
        playStep(tickIndex, nextTickTime);
        tickIndex = (tickIndex + 1) % STEPS;
        nextTickTime += stepDur;

        if (tickIndex === 0) {
          agencyTick();
          maybeScheduledRandom();
        }
      }
    }

    function maybeScheduledRandom(){
      if (state.randEvery <= 0) return;
      const now = performance.now();
      if (state.lastRandAt === 0) state.lastRandAt = now;
      const elapsed = (now - state.lastRandAt) / 1000;
      if (elapsed >= state.randEvery){
        state.lastRandAt = now;
        if (state.agencyMode !== "locked"){
          randomizePreset("auto");
        } else {
          pushLog("warn", "AUTO-RAND: skipped (agency locked)");
        }
      }
    }

    function playStep(i, t){
      const d = state.drum;
      if (d.kick[i] > 0) playKick(t, d.kick[i]);
      if (d.sn[i] > 0) playSnare(t, d.sn[i]);
      if (d.hat[i] > 0){
        const open = d.hat[i] > 1.0;
        playHat(t, open, clamp(d.hat[i], 0.35, 1.0));
      }

      const b = state.bassPattern[i];
      if (b) playBass(t, b.m, b.len, b.acc);

      const l = state.leadPattern[i];
      if (l) playLead(t, l.m, l.len, l.acc);

      if (ac && (i % 4 === 0)){
        const wobble = (Math.random()-0.5) * (18 + 40*state.agencyIntensity*(1-state.stability));
        filter.frequency.setTargetAtTime(clamp(state.fx.cutoff + wobble*40, 120, 8000), t, 0.06);
      }
    }

    $("#midiBtn").addEventListener("click", () => enableMIDI());

    $("#clearMapBtn").addEventListener("click", () => {
      state.midi.maps = {};
      persistMappings();
      renderMappings();
      pushLog("warn", "MIDI: mappings cleared");
      toast("Mappings cleared");
    });

    $("#exportMapBtn").addEventListener("click", async () => {
      const json = JSON.stringify(state.midi.maps, null, 2);
      try{
        await navigator.clipboard.writeText(json);
        toast("Mappings copied");
        pushLog("ok", "MIDI: mappings exported");
      }catch{
        prompt("Copy mappings JSON:", json);
      }
    });

    $("#importMapBtn").addEventListener("click", () => {
      const input = prompt("Paste mappings JSON:");
      if (!input) return;
      try{
        const obj = JSON.parse(input);
        state.midi.maps = obj || {};
        persistMappings();
        renderMappings();
        toast("Mappings imported");
        pushLog("ok", "MIDI: mappings imported");
      }catch{
        toast("Invalid JSON");
        pushLog("bad", "MIDI: import failed");
      }
    });

    async function enableMIDI(){
      if (!navigator.requestMIDIAccess){
        pushLog("bad", "WebMIDI not supported");
        toast("WebMIDI not supported");
        return;
      }
      try{
        const access = await navigator.requestMIDIAccess({ sysex: false });
        state.midi.access = access;
        state.midi.enabled = true;
        $("#midiState").textContent = "MIDI: ON";
        $("#midiState").classList.remove("off");

        const inputs = [...access.inputs.values()];
        if (inputs.length === 0){
          pushLog("warn", "MIDI: enabled but no inputs found");
          toast("No MIDI inputs");
        } else {
          attachMIDIInput(inputs[0]);
          pushLog("ok", `MIDI: input connected (${inputs[0].name || "unknown"})`);
          toast("MIDI enabled");
        }

        access.onstatechange = () => {
          const ins = [...access.inputs.values()];
          if (!state.midi.input && ins.length) attachMIDIInput(ins[0]);
        };

        loadMappings();
        renderMappings();
      } catch (e){
        pushLog("bad", `MIDI: enable failed (${e?.message || e})`);
        toast("MIDI failed");
      }
    }

    function attachMIDIInput(input){
      if (state.midi.input) state.midi.input.onmidimessage = null;
      state.midi.input = input;
      input.onmidimessage = onMIDI;
    }

    function onMIDI(ev){
      const data = ev.data;
      const status = data[0] & 0xF0;
      const cc = data[1];
      const val = data[2];

      if (status === 0xB0){
        if (state.midi.learn){
          const key = state.midi.learn.paramKey;
          state.midi.maps[cc] = { key, min: 0, max: 1 };
          state.midi.learn = null;
          $("#learnPill").textContent = "LEARN: OFF";
          $("#learnPill").classList.add("off");
          persistMappings();
          renderMappings();
          pushLog("ok", `MIDI_LEARN: CC${cc} â†’ ${key}`);
          toast(`Mapped CC${cc}`);
          return;
        }

        const map = state.midi.maps[cc];
        if (!map) return;

        const norm = val / 127;
        setParam(map.key, norm);
      }

      if (status === 0x90 && data[2] > 0){
        if (data[1] === 60) $("#randomNowBtn").click();
        if (data[1] === 61) (state.running ? stop() : $("#startBtn").click());
      }
    }

    const PARAMS = [
      { key: "tempo", label: "Tempo", min: 70, max: 170, ui: "#tempo" },
      { key: "randEvery", label: "Randomize Every (s)", min: 0, max: 30, ui: "#randEvery" },
      { key: "levels.kick", label: "Kick Level", min:0, max:1, ui: "#kick" },
      { key: "levels.bass", label: "Bass Level", min:0, max:1, ui: "#bass" },
      { key: "levels.lead", label: "Lead Level", min:0, max:1, ui: "#lead" },
      { key: "levels.hat",  label: "Hat Level",  min:0, max:1, ui: "#hat" },
      { key: "fx.cutoff", label: "Filter Cutoff", min:120, max:8000, ui: "#cutoff" },
      { key: "fx.q",      label: "Resonance (Q)", min:0.2, max:18,   ui: "#q" },
      { key: "fx.reverb", label: "Reverb",        min:0,   max:0.65, ui: "#reverb" },
      { key: "fx.delay",  label: "Delay",         min:0,   max:0.65, ui: "#delay" },
      { key: "agencyIntensity", label: "Agency Intensity", min:0, max:1, ui: "#agencyIntensity" },
      { key: "stability",       label: "Stability",        min:0, max:1, ui: "#stability" },
      { key: "energy",          label: "Energy",           min:0, max:1, ui: "#energy" }
    ];

    function setParam(key, norm){
      const p = PARAMS.find(x => x.key === key);
      if (!p) return;

      const v = p.min + (p.max - p.min) * norm;

      if (key === "tempo"){
        state.tempo = Math.round(v);
        $("#tempo").value = state.tempo;
        $("#tempoVal").textContent = String(state.tempo);
      } else if (key === "randEvery"){
        state.randEvery = Math.round(v);
        $("#randEvery").value = state.randEvery;
        $("#randEveryVal").textContent = String(state.randEvery);
      } else if (key.startsWith("levels.")){
        const k = key.split(".")[1];
        state.levels[k] = +clamp(v, 0, 1).toFixed(2);
        $(p.ui).value = state.levels[k];
        $("#"+k+"Val").textContent = state.levels[k].toFixed(2);
      } else if (key.startsWith("fx.")){
        const k = key.split(".")[1];
        if (k === "cutoff"){
          state.fx.cutoff = Math.round(v);
          $("#cutoff").value = state.fx.cutoff;
          $("#cutoffVal").textContent = String(state.fx.cutoff);
        } else if (k === "q"){
          state.fx.q = +clamp(v, 0.2, 18).toFixed(1);
          $("#q").value = state.fx.q;
          $("#qVal").textContent = state.fx.q.toFixed(1);
        } else {
          state.fx[k] = +clamp(v, 0, 0.65).toFixed(2);
          if (k === "reverb") { $("#reverb").value = state.fx.reverb; $("#revVal").textContent = state.fx.reverb.toFixed(2); }
          if (k === "delay")  { $("#delay").value  = state.fx.delay;  $("#delVal").textContent = state.fx.delay.toFixed(2); }
        }
      } else if (key === "agencyIntensity"){
        state.agencyIntensity = +clamp(v,0,1).toFixed(2);
        $("#agencyIntensity").value = state.agencyIntensity;
        $("#agiVal").textContent = state.agencyIntensity.toFixed(2);
      } else if (key === "stability"){
        state.stability = +clamp(v,0,1).toFixed(2);
        $("#stability").value = state.stability;
        $("#stabVal").textContent = state.stability.toFixed(2);
      } else if (key === "energy"){
        state.energy = +clamp(v,0,1).toFixed(2);
        $("#energy").value = state.energy;
        $("#engVal").textContent = state.energy.toFixed(2);
      }

      applyParamsToAudio();
    }

    function renderMappings(){
      const el = $("#mapping");
      el.innerHTML = "";

      for (const p of PARAMS){
        const row = document.createElement("div");
        row.className = "maprow";

        const mapped = Object.entries(state.midi.maps).find(([,m]) => m.key === p.key);
        const ccLabel = mapped ? `CC${mapped[0]}` : "â€”";

        row.innerHTML = `
          <div class="left">
            <b>${p.label}</b>
            <span>Mapped: ${ccLabel}</span>
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap;">
            <button class="btn secondary" type="button" data-learn="${p.key}">Learn</button>
            <button class="btn danger" type="button" data-unmap="${p.key}">Unmap</button>
          </div>
        `;
        el.appendChild(row);
      }

      $$('button[data-learn]', el).forEach(b => {
        b.addEventListener("click", () => {
          if (!state.midi.enabled){ toast("Enable MIDI first"); pushLog("warn", "MIDI_LEARN: refused (MIDI off)"); return; }
          state.midi.learn = { paramKey: b.dataset.learn };
          $("#learnPill").textContent = `LEARN: ${b.dataset.learn}`;
          $("#learnPill").classList.remove("off");
          toast("Move a MIDI knobâ€¦");
          pushLog("ok", `MIDI_LEARN: armed for ${b.dataset.learn}`);
        });
      });

      $$('button[data-unmap]', el).forEach(b => {
        b.addEventListener("click", () => {
          const key = b.dataset.unmap;
          for (const [cc, m] of Object.entries(state.midi.maps)){
            if (m.key === key) delete state.midi.maps[cc];
          }
          persistMappings();
          renderMappings();
          toast("Unmapped");
          pushLog("warn", `MIDI: unmapped ${key}`);
        });
      });

      const c = Object.keys(state.midi.maps).length;
      $("#mapCount").textContent = `${c} mapped`;
    }

    function persistMappings(){
      try{ localStorage.setItem("cybershell_midi_maps", JSON.stringify(state.midi.maps)); }catch{}
    }
    function loadMappings(){
      try{
        const raw = localStorage.getItem("cybershell_midi_maps");
        if (raw) state.midi.maps = JSON.parse(raw) || {};
      }catch{}
    }

    function currentPreset(){
      return {
        tempo: state.tempo,
        scene: state.scene,
        agencyMode: state.agencyMode,
        agencyIntensity: state.agencyIntensity,
        stability: state.stability,
        energy: state.energy,
        randEvery: state.randEvery,
        levels: {...state.levels},
        fx: {...state.fx},
        key: state.key,
        scale: state.scale,
        seed: state.seed,
        bassPattern: state.bassPattern,
        leadPattern: state.leadPattern,
        drum: state.drum
      };
    }

    function applyPreset(p){
      if (!p) return;
      state.tempo = p.tempo ?? state.tempo;
      state.scene = p.scene ?? state.scene;
      state.agencyMode = p.agencyMode ?? state.agencyMode;
      state.agencyIntensity = p.agencyIntensity ?? state.agencyIntensity;
      state.stability = p.stability ?? state.stability;
      state.energy = p.energy ?? state.energy;
      state.randEvery = p.randEvery ?? state.randEvery;
      state.levels = {...state.levels, ...(p.levels||{})};
      state.fx = {...state.fx, ...(p.fx||{})};
      state.key = p.key ?? state.key;
      state.scale = p.scale ?? state.scale;
      state.seed = p.seed ?? state.seed;
      state.bassPattern = p.bassPattern ?? state.bassPattern;
      state.leadPattern = p.leadPattern ?? state.leadPattern;
      state.drum = p.drum ?? state.drum;

      $("#tempo").value = state.tempo; $("#tempoVal").textContent = String(state.tempo);
      $("#scene").value = state.scene;
      $("#agencyMode").value = state.agencyMode;
      $("#agencyIntensity").value = state.agencyIntensity; $("#agiVal").textContent = state.agencyIntensity.toFixed(2);
      $("#stability").value = state.stability; $("#stabVal").textContent = state.stability.toFixed(2);
      $("#energy").value = state.energy; $("#engVal").textContent = state.energy.toFixed(2);
      $("#randEvery").value = state.randEvery; $("#randEveryVal").textContent = String(state.randEvery);

      $("#kick").value = state.levels.kick; $("#kickVal").textContent = state.levels.kick.toFixed(2);
      $("#bass").value = state.levels.bass; $("#bassVal").textContent = state.levels.bass.toFixed(2);
      $("#lead").value = state.levels.lead; $("#leadVal").textContent = state.levels.lead.toFixed(2);
      $("#hat").value  = state.levels.hat;  $("#hatVal").textContent  = state.levels.hat.toFixed(2);

      $("#cutoff").value = state.fx.cutoff; $("#cutoffVal").textContent = String(state.fx.cutoff);
      $("#q").value      = state.fx.q;      $("#qVal").textContent      = state.fx.q.toFixed(1);
      $("#delay").value  = state.fx.delay;  $("#delVal").textContent     = state.fx.delay.toFixed(2);
      $("#reverb").value = state.fx.reverb; $("#revVal").textContent     = state.fx.reverb.toFixed(2);

      updateSceneUI();
      applyParamsToAudio();
    }

    function savePreset(){
      const p = currentPreset();
      try{
        localStorage.setItem("cybershell_preset", JSON.stringify(p));
        toast("Preset saved");
        pushLog("ok", "PRESET: saved");
      }catch{
        toast("Save failed");
        pushLog("bad", "PRESET: save failed");
      }
    }

    function loadPreset(){
      try{
        const raw = localStorage.getItem("cybershell_preset");
        if (!raw){ toast("No preset saved"); pushLog("warn", "PRESET: none found"); return; }
        applyPreset(JSON.parse(raw));
        toast("Preset loaded");
        pushLog("ok", "PRESET: loaded");
      }catch{
        toast("Load failed");
        pushLog("bad", "PRESET: load failed");
      }
    }

    updateSceneUI();
    $("#agencyModeLabel").textContent = state.agencyMode[0].toUpperCase() + state.agencyMode.slice(1);
    $("#schedPill").textContent = state.randEvery > 0 ? `AUTO-RAND: ${state.randEvery}s` : "AUTO-RAND: OFF";
    $("#schedPill").classList.toggle("off", state.randEvery === 0);

    pushLog("ok", "VISUAL_LAYER: initialized");
    pushLog("ok", "AGENCY: armed");
    pushLog("warn", "AUDIO: waiting for user gesture");

    loadMappings();
    renderMappings();

  </script>
</body>
</html>
